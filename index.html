<html>

<head>
    <title>Maze Generator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>

<body>
    <div id="mainContainer" class="container-fluid p-3 text-center">
        <div class="row">
            <div class="col-10">
                <canvas id="mazeCanvas"></canvas>
            </div>
            <div id="controlPanel" class="col-2">
                <h3>Maze Generator</h3>
                <form id="mazeForm">
                    <div class="mb-3">
                        <label for="rowsInput" class="form-label">Rows:</label>
                        <input type="number" class="form-control" id="rowsInput" value="20" min="5" max="100">
                    </div>
                    <div class="mb-3">
                        <label for="colsInput" class="form-label">Columns:</label>
                        <input type="number" class="form-control" id="colsInput" value="20" min="5" max="100">
                    </div>
                    <div class="mb-3">
                        <label for="animationSpeedInput" class="form-label">Animation Speed:</label>
                        <input type="range" class="form-range" id="animationSpeedInput" value="1000" min="1" max="1000">
                    </div>
                    <div class="mb-3">
                        <label for="algorithmSelect" class="form-label">Algorithm:</label>
                        <select class="form-select" id="algorithmSelect">
                            <option value="recursiveBacktracker" selected>Recursive Backtracker</option>
                            <option value="binaryTree">Binary Tree Algorithm</option>
                            <option value="prims">Prim's Algorithm</option>
                            <option value="kruskals">Kruskal's Algorithm</option>
                            <option value="aldousBroder">Aldous-Broder Algorithm</option>
                        </select>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="generateMaze()">Generate Maze</button>
                </form>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const canvas = document.getElementById('mazeCanvas');
        const context = canvas.getContext('2d');
        canvas.width = window.innerWidth * 0.83; // 83% width for canvas
        canvas.height = window.innerHeight;

        let cols = 20;
        let rows = 20;
        let cellWidth = canvas.width / cols;
        let cellHeight = canvas.height / rows;

        let animationSpeed = 0; // milliseconds

        document.getElementById('animationSpeedInput').addEventListener('change', (e) => {
            animationSpeed = 1000 - parseInt(e.target.value);
        });

        let maze = [[]];
        for (let i = 0; i < rows; i++) {
            maze[i] = [];
            for (let j = 0; j < cols; j++) {
                maze[i][j] = { right: true, bottom: true }; // Initialize all cells with all walls
            }
        }

        function drawGrid() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.lineWidth = 2;
            context.strokeStyle = '#000';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let x = j * cellWidth;
                    let y = i * cellHeight;
                    // Draw left wall
                    if (j === 0) {
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(x, y + cellHeight);
                        context.stroke();
                    }

                    // Draw top wall
                    if (i === 0) {
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(x + cellWidth, y);
                        context.stroke();
                    }

                    // Draw right wall
                    if (maze[i][j].right) {
                        context.beginPath();
                        context.moveTo(x + cellWidth, y);
                        context.lineTo(x + cellWidth, y + cellHeight);
                        context.stroke();
                    }

                    // Draw bottom wall
                    if (maze[i][j].bottom) {
                        context.beginPath();
                        context.moveTo(x, y + cellHeight);
                        context.lineTo(x + cellWidth, y + cellHeight);
                        context.stroke();
                    }
                }
            }
        }
        drawGrid();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.83; // 83% width for canvas
            canvas.height = window.innerHeight;
            cellWidth = canvas.width / cols;
            cellHeight = canvas.height / rows;
            drawGrid();
        });

        let deltaTime = 0;
        let lastFrameTime = 0;
        let stack = [];

        function animate() {
            if (stack.length === 0) return;
            let now = performance.now();
            deltaTime += now - lastFrameTime;
            lastFrameTime = now;

            if (deltaTime < animationSpeed) {
                requestAnimationFrame(() => animate());
                return;
            }

            deltaTime = 0;

            let [row, col, wall] = stack[0];
            stack.shift();
            if (wall === 'right') {
                maze[row][col].right = false;
            } else if (wall === 'bottom') {
                maze[row][col].bottom = false;
            }
            drawGrid();
            requestAnimationFrame(() => animate());
        }

        function recursiveBacktracker() {
            let visited = Array.from({ length: rows }, () => Array(cols).fill(false));
            function run(row, col) {
                if (row < 0 || col < 0 || row >= rows || col >= cols || visited[row][col]) {
                    return;
                }
                visited[row][col] = true;
                let directions = [
                    [0, 1, 'right'],   // right
                    [1, 0, 'bottom'],  // down
                    [0, -1, 'left'],   // left
                    [-1, 0, 'top']     // up
                ];
                directions = directions.sort(() => Math.random() - 0.5);
                for (let [dr, dc, wall] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    if (newRow >= 0 && newCol >= 0 && newRow < rows && newCol < cols && !visited[newRow][newCol]) {
                        if (wall === 'right') {
                            maze[row][col].right = false;
                            stack.push([row, col, "right"]);
                        } else if (wall === 'bottom') {
                            maze[row][col].bottom = false;
                            stack.push([row, col, "bottom"]);
                        } else if (wall === 'left') {
                            maze[newRow][newCol].right = false;
                            stack.push([newRow, newCol, "right"]);
                        } else if (wall === 'top') {
                            maze[newRow][newCol].bottom = false;
                            stack.push([newRow, newCol, "bottom"]);
                        }
                        run(newRow, newCol);
                    }
                }
            }

            run(0, 0);
            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );
            drawGrid();
            animate(stack);
        }

        function binaryTree() {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let directions = [];
                    if (j < cols - 1) directions.push('right');
                    if (i < rows - 1) directions.push('bottom');
                    if (directions.length > 0) {
                        let choice = directions[Math.floor(Math.random() * directions.length)];
                        if (choice === 'right') {
                            maze[i][j].right = false;
                            stack.push([i, j, "right"]);
                        } else if (choice === 'bottom') {
                            maze[i][j].bottom = false;
                            stack.push([i, j, "bottom"]);
                        }
                    }
                }
            }

            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );
            drawGrid();
            animate(stack);
        }

        function prims() {
            let visited = Array.from({ length: rows }, () => Array(cols).fill(false));
            let edges = []; // This will store potential walls to carve

            // Start from a random cell
            let startRow = Math.floor(Math.random() * rows);
            let startCol = Math.floor(Math.random() * cols);
            visited[startRow][startCol] = true;

            // Add edges from the starting cell to its neighbors
            function addEdges(r, c) {
                // Each edge is [from_row, from_col, direction, to_row, to_col]
                if (r > 0 && !visited[r - 1][c]) edges.push([r, c, 'top', r - 1, c]);
                if (r < rows - 1 && !visited[r + 1][c]) edges.push([r, c, 'bottom', r + 1, c]);
                if (c > 0 && !visited[r][c - 1]) edges.push([r, c, 'left', r, c - 1]);
                if (c < cols - 1 && !visited[r][c + 1]) edges.push([r, c, 'right', r, c + 1]);
            }
            addEdges(startRow, startCol);

            while (edges.length > 0) {
                // Pick a random edge from the list
                let randomIndex = Math.floor(Math.random() * edges.length);
                let [fromR, fromC, direction, toR, toC] = edges.splice(randomIndex, 1)[0];

                // If the cell on the other side of the edge is not visited, carve the wall
                if (!visited[toR][toC]) {
                    visited[toR][toC] = true;

                    // Carve the correct wall based on the direction
                    if (direction === 'right') {
                        maze[fromR][fromC].right = false;
                        stack.push([fromR, fromC, "right"]);
                    } else if (direction === 'bottom') {
                        maze[fromR][fromC].bottom = false;
                        stack.push([fromR, fromC, "bottom"]);
                    } else if (direction === 'left') {
                        maze[toR][toC].right = false; // Carve the right wall of the destination
                        stack.push([toR, toC, "right"]);
                    } else if (direction === 'top') {
                        maze[toR][toC].bottom = false; // Carve the bottom wall of the destination
                        stack.push([toR, toC, "bottom"]);
                    }

                    // Add all new edges from the newly visited cell
                    addEdges(toR, toC);
                }
            }

            // Reset the maze and animate the carving process
            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );
            drawGrid();
            animate();
        }

        function kruskals() {
            let sets = Array.from({ length: rows }, () => Array(cols).fill(0));
            let set_id = 1;
            let walls = [];

            // Assign each cell to a unique set
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    sets[i][j] = set_id++;
                }
            }

            // Create a list of all walls
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (j < cols - 1) walls.push([i, j, 'right', i, j + 1]);
                    if (i < rows - 1) walls.push([i, j, 'bottom', i + 1, j]);
                }
            }

            // Shuffle the walls
            walls.sort(() => Math.random() - 0.5);

            for (let [r1, c1, wall, r2, c2] of walls) {
                if (sets[r1][c1] !== sets[r2][c2]) {
                    // Carve the wall
                    if (wall === 'right') {
                        maze[r1][c1].right = false;
                        stack.push([r1, c1, "right"]);
                    } else {
                        maze[r1][c1].bottom = false;
                        stack.push([r1, c1, "bottom"]);
                    }

                    // Merge the sets
                    let old_set_id = sets[r2][c2];
                    let new_set_id = sets[r1][c1];
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            if (sets[i][j] === old_set_id) {
                                sets[i][j] = new_set_id;
                            }
                        }
                    }
                }
            }

            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );
            drawGrid();
            animate(stack);
        }

        function aldousBroder() {
            let visited = Array.from({ length: rows }, () => Array(cols).fill(false));
            let unvisitedCount = rows * cols;

            // Start at a random cell
            let currentRow = Math.floor(Math.random() * rows);
            let currentCol = Math.floor(Math.random() * cols);
            visited[currentRow][currentCol] = true;
            unvisitedCount--;

            while (unvisitedCount > 0) {
                // Define all possible directions
                let directions = [
                    [0, 1, 'right'],   // right
                    [1, 0, 'bottom'],  // down
                    [0, -1, 'left'],   // left
                    [-1, 0, 'top']     // up
                ];

                // Pick a random direction to attempt to move
                let [dr, dc, wall] = directions[Math.floor(Math.random() * directions.length)];
                let newRow = currentRow + dr;
                let newCol = currentCol + dc;

                // Check if the new position is within bounds
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    if (!visited[newRow][newCol]) {
                        // If the new cell is unvisited, carve the wall and mark it visited
                        if (wall === 'right') {
                            maze[currentRow][currentCol].right = false;
                            stack.push([currentRow, currentCol, "right"]);
                        } else if (wall === 'bottom') {
                            maze[currentRow][currentCol].bottom = false;
                            stack.push([currentRow, currentCol, "bottom"]);
                        } else if (wall === 'left') {
                            maze[newRow][newCol].right = false; // Carve the right wall of the new cell
                            stack.push([newRow, newCol, "right"]);
                        } else if (wall === 'top') {
                            maze[newRow][newCol].bottom = false; // Carve the bottom wall of the new cell
                            stack.push([newRow, newCol, "bottom"]);
                        }
                        visited[newRow][newCol] = true;
                        unvisitedCount--;
                    }
                    // Move to the new cell regardless of whether it was visited before
                    currentRow = newRow;
                    currentCol = newCol;
                }
                // If the move is out of bounds, the loop simply continues and picks a new direction
            }

            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );
            drawGrid();
            animate(stack);
        }

        function generateMaze() {
            cols = parseInt(document.getElementById('colsInput').value);
            rows = parseInt(document.getElementById('rowsInput').value);
            cellWidth = canvas.width / cols;
            cellHeight = canvas.height / rows;

            maze = Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => ({ right: true, bottom: true }))
            );

            drawGrid();

            stack = [];
            deltaTime = 0;
            lastFrameTime = 0;

            const algorithm = document.getElementById('algorithmSelect').value;
            if (algorithm === 'recursiveBacktracker') {
                recursiveBacktracker();
            } else if (algorithm === 'binaryTree') {
                binaryTree();
            } else if (algorithm === 'prims') {
                prims();
            } else if (algorithm === 'kruskals') {
                kruskals();
            } else if (algorithm === 'aldousBroder') {
                aldousBroder();
            }
        }

    </script>
</body>

</html>