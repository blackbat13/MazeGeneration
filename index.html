<html>
<head>
    <title>Maze Generator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"> 
    <link rel="stylesheet" type="text/css" href="assets/css/main.css">
</head>
<body>
    <div id="mainContainer" class="container-fluid p-3 text-center">
        <div class="row">
            <div class="col-10">
                <canvas id="mazeCanvas"></canvas>
            </div>
            <div id="controlPanel" class="col-2">
                <h3>Maze Generator</h3>
                <form id="mazeForm">
                    <div class="mb-3">
                        <label for="rowsInput" class="form-label">Rows:</label>
                        <input type="number" class="form-control" id="rowsInput" value="20" min="5" max="100">
                    </div>
                    <div class="mb-3">
                        <label for="colsInput" class="form-label">Columns:</label>
                        <input type="number" class="form-control" id="colsInput" value="20" min="5" max="100">
                    </div>
                    <div class="mb-3">
                        <label for="animationSpeedInput" class="form-label">Animation Speed:</label>
                        <input type="range" class="form-range" id="animationSpeedInput" value="1000" min="1" max="1000">
                    </div>
                    <div class="mb-3">
                        <label for="algorithmSelect" class="form-label">Algorithm:</label>
                        <select class="form-select" id="algorithmSelect">
                            <option value="recursiveBacktracker" selected>Recursive Backtracker</option>
                            <!-- <option value="prim">Prim's Algorithm</option>
                            <option value="kruskal">Kruskal's Algorithm</option> -->
                            <option value="binaryTree">Binary Tree Algorithm</option>
                        </select>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="generateMaze()">Generate Maze</button>
                </form>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const canvas = document.getElementById('mazeCanvas');
        const context = canvas.getContext('2d');
        canvas.width = window.innerWidth * 0.83; // 83% width for canvas
        canvas.height = window.innerHeight;

        let cols = 20;
        let rows = 20;
        let cellWidth = canvas.width / cols;
        let cellHeight = canvas.height / rows;

        let animationSpeed = 0; // milliseconds

        document.getElementById('animationSpeedInput').addEventListener('change', (e) => {
            animationSpeed = 1000 - parseInt(e.target.value);
        });

        let maze = [[]];
        for (let i = 0; i < rows; i++) {
            maze[i] = [];
            for (let j = 0; j < cols; j++) {
                maze[i][j] = {right: true, bottom: true}; // Initialize all cells with all walls
            }
        }

        function drawGrid() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.lineWidth = 2;
            context.strokeStyle = '#000';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let x = j * cellWidth;
                    let y = i * cellHeight;
                    // Draw left wall
                    if (j === 0) {
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(x, y + cellHeight);
                        context.stroke();
                    }

                    // Draw top wall
                    if (i === 0) {
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(x + cellWidth, y);
                        context.stroke();
                    }

                    // Draw right wall
                    if (maze[i][j].right) {
                        context.beginPath();
                        context.moveTo(x + cellWidth, y);
                        context.lineTo(x + cellWidth, y + cellHeight);
                        context.stroke();
                    }

                    // Draw bottom wall
                    if (maze[i][j].bottom) {
                        context.beginPath();
                        context.moveTo(x, y + cellHeight);
                        context.lineTo(x + cellWidth, y + cellHeight);
                        context.stroke();
                    }
                }
            }
        }
        drawGrid();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.83; // 83% width for canvas
            canvas.height = window.innerHeight;
            cellWidth = canvas.width / cols;
            cellHeight = canvas.height / rows;
            drawGrid();
        });

        let deltaTime = 0;
        let lastFrameTime = 0;

        function animate(stack) {
            if (stack.length === 0) return;
            let now = performance.now();
            deltaTime += now - lastFrameTime;
            lastFrameTime = now;

            if (deltaTime < animationSpeed) {
                requestAnimationFrame(() => animate(stack));
                return;
            }

            deltaTime = 0;

            let [row, col, wall] = stack[0];
            stack.shift();
            if (wall === 'right') {
                maze[row][col].right = false;
            } else if (wall === 'bottom') {
                maze[row][col].bottom = false;
            }
            drawGrid();
            requestAnimationFrame(() => animate(stack));
        }

        function recursiveBacktracker() {
            let visited = Array.from({ length: rows }, () => Array(cols).fill(false));
            let stack = [];
            function run(row, col) {
                if (row < 0 || col < 0 || row >= rows || col >= cols || visited[row][col]) {
                    return;
                }
                visited[row][col] = true;
                let directions = [
                    [0, 1, 'right'],   // right
                    [1, 0, 'bottom'],  // down
                    [0, -1, 'left'],   // left
                    [-1, 0, 'top']     // up
                ];
                directions = directions.sort(() => Math.random() - 0.5);
                for (let [dr, dc, wall] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    if (newRow >= 0 && newCol >= 0 && newRow < rows && newCol < cols && !visited[newRow][newCol]) {
                        if (wall === 'right') {
                            maze[row][col].right = false;
                            stack.push([row, col, "right"]);
                        } else if (wall === 'bottom') {
                            maze[row][col].bottom = false;
                            stack.push([row, col, "bottom"]);
                        } else if (wall === 'left') {
                            maze[newRow][newCol].right = false;
                            stack.push([newRow, newCol, "right"]);
                        } else if (wall === 'top') {
                            maze[newRow][newCol].bottom = false;
                            stack.push([newRow, newCol, "bottom"]);
                        }
                        run(newRow, newCol);
                    }
                }
            }

            run(0, 0);
            maze = Array.from({ length: rows }, () => 
                Array.from({ length: cols }, () => ({right: true, bottom: true}))
            );
            drawGrid();
            animate(stack);
        }

        function binaryTree() {
            let stack = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let directions = [];
                    if (j < cols - 1) directions.push('right');
                    if (i < rows - 1) directions.push('bottom');
                    if (directions.length > 0) {
                        let choice = directions[Math.floor(Math.random() * directions.length)];
                        if (choice === 'right') {
                            maze[i][j].right = false;
                            stack.push([i, j, "right"]);
                        } else if (choice === 'bottom') {
                            maze[i][j].bottom = false;
                            stack.push([i, j, "bottom"]);
                        }
                    }
                }
            }

            maze = Array.from({ length: rows }, () => 
                Array.from({ length: cols }, () => ({right: true, bottom: true}))
            );
            drawGrid();
            animate(stack);
        }

        function generateMaze() {
            cols = parseInt(document.getElementById('colsInput').value);
            rows = parseInt(document.getElementById('rowsInput').value);
            cellWidth = canvas.width / cols;
            cellHeight = canvas.height / rows;

            maze = Array.from({ length: rows }, () => 
                Array.from({ length: cols }, () => ({right: true, bottom: true}))
            );

            drawGrid();

            const algorithm = document.getElementById('algorithmSelect').value;
            if (algorithm === 'recursiveBacktracker') {
                recursiveBacktracker();
            } else if (algorithm === 'binaryTree') {
                binaryTree();
            }
            // Additional algorithms can be added here
        }
        
    </script>
</body>
</html>